#!/bin/sh

#╔═════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
#║ Shell functions compatible with BASH & ZSH                                                                          ║
#╚═════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

#╔═════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
#║ Overview                                                                                                            ║
#║ --------                                                                                                            ║
#║ _has()             - Check if a program is installed                                                                ║
#║ __has()            - Check if a program is installed and return a message if not found                              ║
#║ confirm()          - Confirm user input and based on it, proceed or abort the operation at hand                     ║
#║ open_command()     - Cross-platform open command                                                                    ║
#║ detect_clipboard() - Defines two clipboard functions, clipcopy() and clippaste(), based on the detected platform    ║
#║ copyabsolutepath() - Copy the absolute path of a given directory/file ($PWD if no parameter given) to the clipboard ║
#║ glog()             - Fuzzy search git commits on the current branch                                                 ║
#║ gco()              - Fuzzy git checkout branch/tag/commit across all remotes                                        ║
#║ ga()               - Fuzzy git add                                                                                  ║
#║ ff()               - Fuzzy find a file or directory                                                                 ║
#║ fkill()            - Fuzzy find a process and kill it                                                               ║
#║ cdrr()             - cd to the outermost git repository directory                                                   ║
#║ gh()               - Open GitHub page of a repository from the terminal                                             ║
#║ od()               - Run a command, disown the process and then return to prompt without terminating the command    ║
#║ remove_spaces()    - Remove spaces recursively in folder and file names                                             ║
#║ update_dnf()       - Run updates for DNF package manager                                                            ║
#║ update_apt()       - Run updates for APT package manager                                                            ║
#║ update_flatpaks()  - Run updates for Flatpak package manager                                                        ║
#║ update_snaps()     - Run updates for Snap package manager                                                           ║
#║ do_update()        - Identify the distro-specific package manager and run system updates and cleanup                ║
#╚═════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════ #

# _has() - Check if a program is installed

_has()
{
    command -v $1 >/dev/null 2>&1;
}

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════ #

# __has() - Check if a program is installed and return a message if not found

__has()
{
    if ! _has $1; then printf "$1 not found.\n"; return 1; fi
}

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════ #

# confirm() - Confirm user input and based on it, proceed or abort the operation at hand

# Usage (call with a prompt string or use a default):
# - With custom user input:
#        $ if confirm 'Install Software?'; then echo "Installing Software"; else echo "Cancelled"; fi
# - Without user input (uses default message):
#        $ if confirm; then echo "Done"; else echo "Cancelled"; fi

confirm()
{
    local message="${1:-Are you sure you want to continue? [Y]es or [N]o and then press ENTER.}"

    while true; do
        if   [ -n "$ZSH_VERSION" ];  then read "REPLY?$message ";
        elif [ -n "$BASH_VERSION" ]; then read -r -p "$message " REPLY; fi

        case "$REPLY" in
            [yY][eE][sS]|[yY])     printf '\n'; return 0; ;;
            [nN][oO]|[nN])         printf '\n'; return 1; ;;
            *)                     printf '\nPlease reply with either [Y]es or [N]o.\n'; ;;
        esac
    done
}

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════ #

# open_command() - Cross-platform open command

open_command()
{
    local open_cmd

    case "$OSTYPE" in

        darwin*)    open_cmd='open' ;;

        cygwin*)    open_cmd='cygstart' ;;

        linux*)     if [[ $(uname -r) = *icrosoft* ]]; then
                        open_cmd='wslview';
                    else
                        open_cmd='nohup xdg-open';
                    fi ;;

        msys*)      open_cmd='start ""' ;;

        *)          printf "Platform $OSTYPE not supported.\n"; return 1; ;;

    esac

    ${=open_cmd} "$@" &>/dev/null;
}

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════ #

# detect_clipboard() - Defines two clipboard functions, clipcopy() and clippaste(), based on the detected platform

# clipcopy() - Copy data to clipboard
#    <command> | clipcopy  - copies stdin to clipboard
#    clipcopy <file>       - copies a file's contents to clipboard

# clippaste() - Paste data from clipboard to stdout
#    clippaste             - paste clipboard's contents to stdout
#    clippaste | <command> - pipe clipboard's content to another process
#    clippaste > <file>    - paste contents to a file

detect_clipboard()
{
    emulate -L zsh

    if [[ "${OSTYPE}" == darwin* ]] && _has pbcopy && _has pbpaste; then
        clipcopy()  { pbcopy < "${1:-/dev/stdin}"; }
        clippaste() { pbpaste; }

    elif [[ "${OSTYPE}" == (cygwin|msys)* ]]; then
        clipcopy()  { cat "${1:-/dev/stdin}" > /dev/clipboard; }
        clippaste() { cat /dev/clipboard; }

    elif [ -n "${WAYLAND_DISPLAY:-}" ] && _has wl-copy && _has wl-paste; then
        clipcopy()  { wl-copy < "${1:-/dev/stdin}"; }
        clippaste() { wl-paste; }

    elif [ -n "${DISPLAY:-}" ] && _has xclip; then
        clipcopy()  { xclip -in -selection clipboard < "${1:-/dev/stdin}"; }
        clippaste() { xclip -out -selection clipboard; }

    elif [ -n "${DISPLAY:-}" ] && _has xsel; then
        clipcopy()  { xsel --clipboard --input < "${1:-/dev/stdin}"; }
        clippaste() { xsel --clipboard --output; }

    elif [ -n "${TMUX:-}" ] && _has tmux; then
        clipcopy()  { tmux load-buffer "${1:--}"; }
        clippaste() { tmux save-buffer -; }

    elif [[ $(uname -r) = *icrosoft* ]]; then
        clipcopy()  { clip.exe < "${1:-/dev/stdin}"; }
        clippaste() { powershell.exe -noprofile -command Get-Clipboard; }

    else
        _retry_clipboard_detection_or_fail()
        {
            local clipcmd="${1}"; shift
            if detect_clipboard; then
                "${clipcmd}" "$@"
            else
                print "${clipcmd}: Platform $OSTYPE not supported or xclip/xsel not installed" >&2
                return 1
            fi
        }
        clipcopy() { _retry_clipboard_detection_or_fail clipcopy "$@"; }
        clippaste() { _retry_clipboard_detection_or_fail clippaste "$@"; }
        return 1
    fi
}

# Detect at startup. A non-zero exit here indicates that the dummy clipboards were set,
# which is not really an error. If the user calls them, they will attempt to re-detect
# (for example, perhaps the user has now installed xclip) and then either print an error
# or proceed successfully.
detect_clipboard || true;

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════ #

# copyabsolutepath() - Copy the absolute path of a given directory/file ($PWD if no parameter given) to the clipboard

# Dependencies: clipcopy()

copyabsolutepath() {
    # If no argument passed, use current directory
    local file="${1:-$PWD}";

    # If argument is not an absolute path, prepend $PWD
    [[ $file = /* ]] || file="$PWD/$file";

    # Copy the absolute path without resolving symlinks and if clipcopy fails, exit with an error
    print -n "${file:a}" | clipcopy || return 1;

    # Message with the path in bold letters
    printf ${(%):-"%B\"${file:a}\"%b copied to clipboard.\n"};
}

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════ #

# glog() - Fuzzy search git commits on the current branch and then press:
#          - ENTER  - git show (what changed in that commit)
#          - CTRL-D - git diff (between that commit and ^HEAD)
#          - CTRL-Y - copy the commit id
#          - CTRL-H - checkout the commit
#          For truncated entries, use ? key to toggle a preview window

# Dependencies: git, fzf, awk, sed, clipcopy()

glog()
{
    if ! git rev-parse --git-dir > /dev/null 2>&1; then printf "Not inside a Git repository. Exiting.\n"; return; fi;

    local out shas sha q k
    while out=$(git log --date=format:'%Y-%m-%d %a' --format=format:'%h  %ad  %<(16,trunc)%an  %>|(1)%s %d' "$@" |
                fzf --no-sort --no-info --query="$q" --print-query --expect=ctrl-d,ctrl-y,ctrl-h  \
                    --preview 'echo {}' --preview-window down:3:hidden:wrap --bind '?:toggle-preview' \
                    --header-first --header='↵: Show | ^D: Diff | ^Y: Copy Hash | ^H: Checkout'); do
        q=$(head -1 <<< "$out");
        k=$(head -2 <<< "$out" | tail -1);
        shas=$(sed '1,2d;s/^[^a-z0-9]*//;/^$/d' <<< "$out" | awk '{print $1}');
        [ -z "$shas" ] && continue
        if   [ "$k" = ctrl-d ]; then git diff --color=always $shas;
        elif [ "$k" = ctrl-y ]; then (printf $shas | clipcopy) && (printf "$shas copied to clipboard.\n") || return 1;
        elif [ "$k" = ctrl-h ]; then git checkout $shas;
        else for sha in $shas; do git show --color=always $sha; done
        fi
    done
}

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════ #

# gco() - Fuzzy git checkout branch/tag

gco()
{
    if ! git rev-parse --git-dir > /dev/null 2>&1; then printf "Not inside a Git repository. Exiting.\n"; return; fi;

    (git branch --all && git tag) | fzf | xargs git checkout;
}

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════ #

# ga() - Fuzzy git add

ga()
{
    if ! git rev-parse --git-dir > /dev/null 2>&1; then printf "Not inside a Git repository. Exiting.\n"; return; fi;

    git diff --name-only --line-prefix=`git rev-parse --show-toplevel`/ | fzf | xargs git add -v;
}

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════ #

# ff() - Fuzzy find a file or directory and then press:
#        - ENTER    - cd to the selected entry
#        - CTRL + V - open the selected entry in the default $VISUAL editor
#        - CTRL + N - open the selected entry in the default $EDITOR
#        - CTRL + O - open the selected entry in the default system app
#        - CTRL + E - open the selected entry in the default file explorer
#        - CTRL + Y - yank the selected entry to the clipboard
#        For truncated entries, use ? key to toggle a preview window

# Usage:
# ff <path/to/search>  (if invoked without a path, search under $HOME)

# Dependencies: fzf, fd/locate, copyabsolutepath()

# TODO: For Ctrl-O, use a generic open_in_default_system_app() that works with bash,zsh,linux,wsl,macos
# TODO: For Ctrl-E, use a generic open_in_default_files_app() that works with bash,zsh,linux,wsl,macos

ff()
{
    # entries=("$(locate ${1:-~} |                                                                               \
    entries=("$(fd -I --full-path --hidden --exclude ".git" --color=never . ${1:-~} |                          \
                fzf --preview 'echo {}' --preview-window down:3:hidden:wrap --bind '?:toggle-preview' --exit-0 \
                    --expect=ctrl-o,ctrl-v,ctrl-n,ctrl-y,ctrl-e --header-first                                 \
                    --header='↵:cd | ^E: File Explorer | ^V: $VISUAL | ^N: $EDITOR | ^O: System App | ^Y: Copy')");

    key="$(head -1 <<< "${entries[@]}")";
    sel="$(head -2 <<< "${entries[@]}" | tail -1)" || return;

    if   [[ "$key" == ctrl-o ]]; then open "$sel";
    elif [[ "$key" == ctrl-v ]]; then "$VISUAL" "$sel";
    elif [[ "$key" == ctrl-n ]]; then "$EDITOR" "$sel";
    elif [[ "$key" == ctrl-e ]]; then if [[ -d "$sel" ]]; then xdg-open "$sel"; else xdg-open $(dirname "$sel"); fi
    elif [[ "$key" == ctrl-y ]]; then copyabsolutepath $(printf "$sel");
    elif [[ -d "$sel" ]] ; then cd "$sel"; else cd "$(dirname "$sel")";
    fi
}

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════ #

# fkill() - Fuzzy find a process and kill it

# Dependencies: fzf, sed, awk

fkill()
{
    local pid

    if [ "$UID" != "0" ]; then pid=$(ps -f -u $UID | sed 1d | fzf -m | awk '{print $2}');
    else pid=$(ps -ef | sed 1d | fzf -m | awk '{print $2}');
    fi

    if [ "x$pid" != "x" ]; then printf $pid | xargs kill -${1:-9}; fi
}

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════ #

# cdrr() - cd to the outermost git repository directory

cdrr()
{
    local gitroot="$(git rev-parse --show-toplevel)"
    [ -z "$gitroot" ] && return 1;

    while [ -n "$gitroot" ]; do
        cd "$gitroot" || return 1;
        gitroot="$(git rev-parse --show-superproject-working-tree 2>/dev/null)";
    done

    return 0;
}

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════ #

# gh() - Open GitHub page of a repository from the terminal

# Usage:
# gh from a non git repo gives you an error message and exists
# gh from a repo opens it. Works with github, gitlab, etc...
# gh <remote> opens the remote. For eg, gh upstream.

# Dependencies: git, sed

gh()
{(
    set -e;
    git remote -v | grep push;
    remote=${1:-origin};
    printf "Using remote %s\n" "$remote";

    URL=$(git config remote.$remote.url | sed "s/git@\(.*\):\(.*\).git/https:\/\/\1\/\2/");
    printf "Opening %s\n" "$URL";
    open $URL >/dev/null;
)}

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════ #

# od() - Run a command, disown the process and then return to prompt without terminating the command

# Usage:
# od meld ~/dotfiles ~/repo

od()
{
    "$@" &
    disown;
    return 0;
}

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════ #

# remove_spaces() - Remove spaces recursively in folder and file names

remove_spaces()
{
    find . -depth -name \'* *\' \
    | while IFS= read -r f ; do mv -i \"$f\" \"$(dirname \"$f\")/$(basename \"$f\"|tr \' \' _)\" ; done
}

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════ #

# Update, upgrade and clean dnf, apt, flatpak and snap packages in your system

# TODO
# update_dnf() - Run updates for DNF package manager

update_dnf()
{
    return 0;
}

# update_apt() - Run updates for APT package manager
update_apt()
{
    sudo apt update -qq;

    printf "Checking for available apt updates...\n";

    if __has aptitude; then aptitude search '~U';
    else sudo apt-get -s dist-upgrade | awk '/^Inst/ { print $2 }'; fi

    printf '\n';

    if ! confirm 'Continue ? [y/N]'; then printf "Apt update cancelled.\n\n"; return 1; fi

    # Update
    sudo apt update;
    sudo apt install --fix-missing -y;
    sudo apt upgrade --allow-downgrades -y;
    sudo apt full-upgrade --allow-downgrades -y;

    # Clean-up
    sudo apt install -f;
    sudo apt autoremove -y;
    sudo apt autoclean;
    sudo apt clean;
}

# update_flatpaks() - Run updates for Flatpak package manager
update_flatpaks()
{
    if ! __has flatpak; then return 1; fi
    if ! confirm 'Start Flatpak update ? [y/N]'; then printf "Flatpak update cancelled.\n\n"; return 1; fi

    printf "\nStarting Flatpak update...\n";
    flatpak update -y;

    printf "Doing Flatpak clean-up...\n";
    flatpak uninstall --delete-data -y;
    flatpak uninstall --unused -y;

    printf "Flatpak update finished.\n";
}

# update_snaps() - Run updates for Snap package manager
update_snaps()
{
    if ! confirm 'Start Snap update ? [y/N]'; then printf "Snap update cancelled.\n\n"; return 1; fi
    printf "\nStarting Snap update...\n";
    sudo snap refresh;
    printf "Snap update finished.\n";

}

# do_update() - Identify the distro-specific package manager and run system updates and cleanup
do_update()
{
    if [ -z "$(which apt-get 2>/dev/null)" ]; then echo -e "Not running Ubuntu. Exiting."; return 1; fi

    printf "\nStarting system update...\n";
    update_apt; # TODO: check OS and call the correct package manager here
    update_flatpaks;
    update_snaps;

    printf "Done. It's good practice to do a system reboot now.\n"
}

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════ #

# Dependency check

if ! _has fzf;              then printf "fzf not found.\n";                fi
if ! _has git;              then printf "git not found.\n";                fi
if ! _has sed;              then printf "sed not found.\n";                fi
if ! _has awk;              then printf "awk not found.\n";                fi
if ! _has $EDITOR;          then printf "EDITOR not set.\n";               fi
if ! _has $VISUAL;          then printf "VISUAL editor not set.\n";        fi
if ! _has clipcopy;         then printf "clipcopy() not found.\n";         fi
if ! _has copyabsolutepath; then printf "copyabsolutepath() not found.\n"; fi

# ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════ #
